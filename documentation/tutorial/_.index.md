# Kickstart library tutorial

Kickstart is intended to ease the way for beginners in C++, and helps to shorten example code for those who help others on the net.

## 1. Installation & compiler requirements.

All you need to do is download, copy and rename, so that the compiler finds the `<kickstart/`&hellip;`>` headers. There is no need to compile the library on its own. All the library code is in headers that you just `#include`.

Installation is described in more detail in [a separate document](../../source/examples/hello-world.md).

Then after installation, to use Kickstart you need to use a compiler option that specifies at least ***C++17***. Also, the Kickstart i/o functionality requires that C++ strings are UTF-8 encoded, which they‚Äôre not by default with the 2019 version of Microsoft‚Äôs Visual C++ compiler, and the Kickstart code uses the alternate keywords `and`, `or` and `not`, which again are a problem with Visual C++. Recommended options to guide the compilers:

| *Compiler:* | *Recommended core options:* |
|-|-|
| g++ &amp; clang | `-std=c++17` `-pedantic-errors` `-Wall` |
| Visual C++ | `/nologo` `/utf-8` `/EHsc` `/GR` `/permissive-` `/FI"iso646.h"` `/std:c++17` `/Zc:__cplusplus` `/W4` `/wd4459` `/D` `_CRT_SECURE_NO_WARNINGS` `/D` `_STL_SECURE_NO_WARNINGS` |

Happily, for Visual C++ options can be specified in environment variable `CL`, which is used automatically.

## 2. ‚ÄúHello, world!‚Äù ‚Äî or, keep that console window open, please.

Here‚Äôs the classic ‚ÄúHello, world!‚Äù program expressed with Kickstart console output:

*File ([hello-world.cpp](examples/hello-world.cpp)):*
~~~cpp
#include <kickstart/all.hpp>
using namespace kickstart::all;

auto main() -> int
{
    out << "Hello, world!" << endl;
}
~~~

`out`, `<<` and `endl` are names provided by the Kickstart library in namespace `kickstart::all`. When the output goes to a Windows console then it‚Äôs sent there via the UTF-16 based Windows API function `WriteConsoleW` so that e.g. non-English letters are treated correctly. In all other cases the `out` output is delegated to C‚Äôs `fwrite`.

However, conversion to text of non-textual arguments is handled by passing them to a `std::ostringstream`. That means that C++ iostreams can be be involved and contribute to an unreasonably large executable size, just as with use of `std::cout` output. A future goal is to remove that and *all* dependencies on iostreams so that the size of a C++ ‚ÄúHello, world!‚Äù executable built by a beginner, can be much less unreasonable.

Result in an ordinary Windows console window:

> C:\my\dev\libraries\kickstart-1\documentation\tutorial\examples]  
> \> ***cl hello-world.cpp /Fe"hello"***  
> hello-world.cpp
> 
> [C:\my\dev\libraries\kickstart-1\documentation\tutorial\examples]  
> \> ***hello***  
> Hello, world!

Works! üòÉ

The **`cl`** command invokes the Visual C++ 2019 compiler, and option `/Fe"hello"` tells it to produce an executable named `hello.exe`, which can then be invoked with command `hello`.

---

If you run `hello.exe` by double-clicking the file in Windows Explorer, then apparently nothing happens, except maybe some screen flicker.

What really happens (pretty fast) is:

1. The executable contains information that it should run in the **console subsystem**, i.e. with an associated console window. Windows therefore helpfully creates a new console window for it.
2. The program, unaware that it‚Äôs being run on its very own, presents its ‚ÄúHello, world!‚Äù text in the provided new window and just terminates.
3. Windows notices that there are no longer any processes using the console window, so Windows closes that console window.

Beginners that don't use the Kickstart library, or some other library like Kickstart, therefore typically insert a ‚Äústop here‚Äù statement at the end of the program. It can be a portable input statement, or it can be e.g. a Windows-specific `system("pause")`. Anyway that‚Äôs problematic in several ways:

* Ureliable: in a typical beginner's program the input buffer may not be empty at the end, so that the execution doesn‚Äôt stop at an input statement at the end.
* Unclean: the `main` code becomes less clean, and with a `system` command also needlessly non-portable.
* Premature: at the point where the program stops (if it stops), static cleanup has not yet been performed, so any effects from that can‚Äôt be observed.
* Annoying: when the program is run from a command interpreter the user needlessly has to interact with it to terminate it at the end.
* Obstructive: when the program is used in a script/batch file, including for testing, one must work around the stopping behavior.

With Kickstart you can largely avoid the above five problems by instead **force-including** the `<kickstart/$-keep-console.hpp>` header. Force-including means that you use a compiler option to include it, instead of an `#include` directive in the code. With Visual C++ it‚Äôs option `/FI`, and with g++ it‚Äôs `-include`.

> [C:\my\dev\libraries\kickstart-1\documentation\tutorial\examples]  
> \> ***cl hello-world.cpp /FI"kickstart/$-keep-console.hpp" /Fe"hello"***  
> hello-world.cpp
> 
> [C:\my\dev\libraries\kickstart-1\documentation\tutorial\examples]  
> \> ***hello***  
> Hello, world!

Hey, it‚Äôs just the same as before?!?

Yes, that‚Äôs *by design*. The behavior when the program is run from a command interpreter is exactly the same as before; no change. But watch what happens when it‚Äôs run by double-clicking the executable in Windows Explorer:

![](images/hello-world.shadowed.png "Paused ‚ÄúHello, world!‚Äù console window.")

Yay!

Note: there‚Äôs no *guarantee* that all relevant static cleanup has been performed at this point, because the stopping is done by the destructor of a global object. For example, an earlier opened file that has not been explicitly closed, may still be open so that it can‚Äôt yet be deleted, say. But all static cleanup performed by object destructors will in practice have been performed (unless of course you force-include some other header that uses this technique).









## 3. Text i/o.

### 3.1. Output of non-English letters like Norwegian √Ü√ò√Ö.

Pretend that you‚Äôre a Norwegian student named Bj√∏rn H√•vard S√¶ther. You want to write a portable C++ program that displays your name, whether you compile and run it in Linux or in Windows. That‚Äôs easy with Kickstart:

*File ([bhs.cpp](examples/bhs.cpp)):*
~~~cpp
#include <kickstart/all.hpp>
using namespace kickstart::all;

auto main() -> int
{
    out << "Dear world, Bj√∏rn H√•vard S√¶ther says hello!" << endl;
}
~~~

Building and running in an ordinary Windows console window:

> [C:\my\dev\libraries\kickstart-1\documentation\tutorial\examples]  
> \> ***cl bhs.cpp /Feb***  
> bhs.cpp
> 
> [C:\my\dev\libraries\kickstart-1\documentation\tutorial\examples]  
> \> ***b***  
> Dear world, Bj√∏rn H√•vard S√¶ther says hello!

---

Here‚Äôs code that ideally should do the same, but using the C++ standard library directly:

*File ([bhs.stdlib.cpp](examples/bhs.stdlib.cpp)):*
~~~cpp
#include <iostream>
using namespace std;

auto main() -> int
{
    cout << "Dear world, Bj√∏rn H√•vard S√¶ther says hello!" << endl;
}
~~~

Namespace `std` has a much higher chance of introducing name collisions (e.g. for the name `distance`) than the `kickstart::all` namespace, and so many consider `using namespace std;` a bad practice. A `using namespace std;` generally saves work for a small program like this but it can lead to much unnecessary work in a larger system, so it should only be used with due (intelligent) consideration. Especially a `using namespace std;` in the global namespace in a header, should be avoided.

Anyway, the default standard-library result in a Windows console is ungood:

> [C:\my\dev\libraries\kickstart-1\documentation\tutorial\examples]  
> \> ***cl bhs.stdlib.cpp /Fe"bs"***  
> bhs.stdlib.cpp  
> 
> [C:\my\dev\libraries\kickstart-1\documentation\tutorial\examples]  
> \> ***bs***  
> Dear world, Bj‚îú¬©rn H‚îú√ëvard S‚îú¬™ther says hello!

The gobbledygook appears because the console expects a different text encoding than UTF-8, and because *the Visual C++ standard library implementation does not address that issue*.

This is so also with the other common Windows compilers. The Windows C++ standard library implementations could have done the same as Kickstart, with Just Works&trade; behavior, but they don‚Äôt. Presumably that common misbehavior is due to common *reuse* of a core of flawed functionality in Microsoft‚Äôs C runtime library.

---

Which encoding a Windows console expects, varies, but on the author‚Äôs system the default is Windows **codepage** 850, which is a Scandinavian variant of the original IBM PC text encoding. When the console is instructed to instead expect codepage 65001, UTF-8, the standard library output is presented correctly:

> [C:\my\dev\libraries\kickstart-1\documentation\tutorial\examples]  
> \> ***chcp & bs***  
> Active code page: 850  
> Dear world, Bj‚îú¬©rn H‚îú√ëvard S‚îú¬™ther says hello!
> 
> [C:\my\dev\libraries\kickstart-1\documentation\tutorial\examples]  
> \> ***chcp 65001 & bs***  
> Active code page: 65001  
> Dear world, Bj√∏rn H√•vard S√¶ther says hello!

Here the **`chcp`** command, short for *change codepage*, reports and changes which codepage the console should assume, its ‚Äúactive codepage‚Äù.

Summing up so far, using Kickstart for simple output ‚Ä¶

* has much less chance of name collision for the common `using namespace` technique;
* presents e.g. Norwegian characters correctly *by default*; and
* gives correct text presentation even when `chcp` can't be used, e.g. when the program is run from an IDE.
